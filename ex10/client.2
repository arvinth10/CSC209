Script started on Mon Mar 27 16:23:59 2017
]0;vijaya89@wolf:/h/u12/c5/00/vijaya89/csc209/vijaya89/ex10wolf:~/csc209/vijaya89/ex10$ run 127.0.0.1
bash: run: command not found
]0;vijaya89@wolf:/h/u12/c5/00/vijaya89/csc209/vijaya89/ex10wolf:~/csc209/vijaya89/ex10$ run 127.0.0.1exit[Krun 127.0.0.1[1P[1P[1P[1P[1@r[1@a[1@n[1@d[1@c[1@l[1@i[1@e[1@n[1@t[1@ 
randclient: connect: Connection refused
]0;vijaya89@wolf:/h/u12/c5/00/vijaya89/csc209/vijaya89/ex10wolf:~/csc209/vijaya89/ex10$ p s   gdb randclient
GNU gdb (Ubuntu 7.7.1-0ubuntu5~14.04.2) 7.7.1
Copyright (C) 2014 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<http://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
<http://www.gnu.org/software/gdb/documentation/>.
For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from randclient...done.
(gdb) break main
Breakpoint 1 at 0x4007fd: file randclient.c, line 16.
(gdb) run 127.0.01 .1
Starting program: /h/u12/c5/00/vijaya89/csc209/vijaya89/ex10/randclient 127.0.0.1

Breakpoint 1, main (argc=2, argv=0x7fffffffeb28) at randclient.c:16
16      int main(int argc, char** argv) {
(gdb) p soc
$1 = 32767
(gdb) p message
$2 = '\000' <repeats 16 times>, "\360\t"
(gdb) p soc
$3 = 32767
(gdb) p soc[Kn
18        char message[18] = "A stitch in time\r\n";
(gdb) n
24        if ((soc = socket(AF_INET, SOCK_STREAM, 0)) == -1) {
(gdb) n
29        peer.sin_family = AF_INET;
(gdb) n
30        peer.sin_port = htons(PORT);
(gdb) n
31        if (inet_pton(AF_INET, argv[1], &peer.sin_addr) < 1) {
(gdb) n
37        if (connect(soc, (struct sockaddr *)&peer, sizeof(peer)) == -1) {
(gdb) p b soc
$4 = 3
(gdb) n
42        total_bytes = TIMES * sizeof(message);
(gdb) 
43        current_byte = 0;
(gdb) n
44        while (current_byte < total_bytes) {
(gdb) n
45          howmany = rand() % (MAXCHARS - MINCHARS + 1) + MINCHARS;
(gdb) p soc
$5 = 3
(gdb) n
46          bytes_left = total_bytes - current_byte;
(gdb) n
47          if (howmany > bytes_left) {
(gdb) n
50          for (int i = 0; i < howmany; i++) {
(gdb) n
51            piece[i] = message[(current_byte + i) % sizeof(message)];
(gdb) n
50          for (int i = 0; i < howmany; i++) {
(gdb) p message
$6 = "A stitch in time\r\n"
(gdb) n
51            piece[i] = message[(current_byte + i) % sizeof(message)];
(gdb) n
50          for (int i = 0; i < howmany; i++) {
(gdb) n
51            piece[i] = message[(current_byte + i) % sizeof(message)];
(gdb) n
50          for (int i = 0; i < howmany; i++) {
(gdb) n
51            piece[i] = message[(current_byte + i) % sizeof(message)];
(gdb) n
50          for (int i = 0; i < howmany; i++) {
(gdb) n
51            piece[i] = message[(current_byte + i) % sizeof(message)];
(gdb) n
50          for (int i = 0; i < howmany; i++) {
(gdb) n
51            piece[i] = message[(current_byte + i) % sizeof(message)];
(gdb) n
50          for (int i = 0; i < howmany; i++) {
(gdb) n
53          write(soc, piece, howmany);
(gdb) n
54          current_byte += howmany;
(gdb) n
44        while (current_byte < total_bytes) {
(gdb) n
45          howmany = rand() % (MAXCHARS - MINCHARS + 1) + MINCHARS;
(gdb) n
46          bytes_left = total_bytes - current_byte;
(gdb) n
47          if (howmany > bytes_left) {
(gdb) n
50          for (int i = 0; i < howmany; i++) {
(gdb) n
51            piece[i] = message[(current_byte + i) % sizeof(message)];
(gdb) n
50          for (int i = 0; i < howmany; i++) {
(gdb) n
51            piece[i] = message[(current_byte + i) % sizeof(message)];
(gdb) n
50          for (int i = 0; i < howmany; i++) {
(gdb) n
51            piece[i] = message[(current_byte + i) % sizeof(message)];
(gdb) n
50          for (int i = 0; i < howmany; i++) {
(gdb) n
51            piece[i] = message[(current_byte + i) % sizeof(message)];
(gdb) n
50          for (int i = 0; i < howmany; i++) {
(gdb) n
53          write(soc, piece, howmany);
(gdb) n
54          current_byte += howmany;
(gdb) n
44        while (current_byte < total_bytes) {
(gdb) n
45          howmany = rand() % (MAXCHARS - MINCHARS + 1) + MINCHARS;
(gdb) n
46          bytes_left = total_bytes - current_byte;
(gdb) n
47          if (howmany > bytes_left) {
(gdb) n
50          for (int i = 0; i < howmany; i++) {
(gdb) n
51            piece[i] = message[(current_byte + i) % sizeof(message)];
(gdb) n
50          for (int i = 0; i < howmany; i++) {
(gdb) n
51            piece[i] = message[(current_byte + i) % sizeof(message)];
(gdb) n
50          for (int i = 0; i < howmany; i++) {
(gdb) n
51            piece[i] = message[(current_byte + i) % sizeof(message)];
(gdb) n
50          for (int i = 0; i < howmany; i++) {
(gdb) n
51            piece[i] = message[(current_byte + i) % sizeof(message)];
(gdb) n
50          for (int i = 0; i < howmany; i++) {
(gdb) n
51            piece[i] = message[(current_byte + i) % sizeof(message)];
(gdb) n
50          for (int i = 0; i < howmany; i++) {
(gdb) n
53          write(soc, piece, howmany);
(gdb) n
54          current_byte += howmany;
(gdb) n
44        while (current_byte < total_bytes) {
(gdb) n
45          howmany = rand() % (MAXCHARS - MINCHARS + 1) + MINCHARS;
(gdb) n
46          bytes_left = total_bytes - current_byte;
(gdb) n
47          if (howmany > bytes_left) {
(gdb) n
50          for (int i = 0; i < howmany; i++) {
(gdb) n
51            piece[i] = message[(current_byte + i) % sizeof(message)];
(gdb) n
50          for (int i = 0; i < howmany; i++) {
(gdb) n
51            piece[i] = message[(current_byte + i) % sizeof(message)];
(gdb) n
50          for (int i = 0; i < howmany; i++) {
(gdb) n
51            piece[i] = message[(current_byte + i) % sizeof(message)];
(gdb) n
50          for (int i = 0; i < howmany; i++) {
(gdb) n
53          write(soc, piece, howmany);
(gdb) n
54          current_byte += howmany;
(gdb) n
44        while (current_byte < total_bytes) {
(gdb) n
45          howmany = rand() % (MAXCHARS - MINCHARS + 1) + MINCHARS;
(gdb) n
46          bytes_left = total_bytes - current_byte;
(gdb) n
47          if (howmany > bytes_left) {
(gdb) n
50          for (int i = 0; i < howmany; i++) {
(gdb) n
51            piece[i] = message[(current_byte + i) % sizeof(message)];
(gdb) n
50          for (int i = 0; i < howmany; i++) {
(gdb) n
51            piece[i] = message[(current_byte + i) % sizeof(message)];
(gdb) n
50          for (int i = 0; i < howmany; i++) {
(gdb) n
51            piece[i] = message[(current_byte + i) % sizeof(message)];
(gdb) n
50          for (int i = 0; i < howmany; i++) {
(gdb) n
51            piece[i] = message[(current_byte + i) % sizeof(message)];
(gdb) n
50          for (int i = 0; i < howmany; i++) {
(gdb) n
51            piece[i] = message[(current_byte + i) % sizeof(message)];
(gdb) n
50          for (int i = 0; i < howmany; i++) {
(gdb) n
51            piece[i] = message[(current_byte + i) % sizeof(message)];
(gdb) n
50          for (int i = 0; i < howmany; i++) {
(gdb) n
53          write(soc, piece, howmany);
(gdb) n
54          current_byte += howmany;
(gdb) nn
Undefined command: "nn".  Try "help".
(gdb) n
44        while (current_byte < total_bytes) {
(gdb) n
45          howmany = rand() % (MAXCHARS - MINCHARS + 1) + MINCHARS;
(gdb) n
46          bytes_left = total_bytes - current_byte;
(gdb) n
47          if (howmany > bytes_left) {
(gdb) n
50          for (int i = 0; i < howmany; i++) {
(gdb) n
51            piece[i] = message[(current_byte + i) % sizeof(message)];
(gdb) n
50          for (int i = 0; i < howmany; i++) {
(gdb) n
51            piece[i] = message[(current_byte + i) % sizeof(message)];
(gdb) n
50          for (int i = 0; i < howmany; i++) {
(gdb) n
51            piece[i] = message[(current_byte + i) % sizeof(message)];
(gdb) n
50          for (int i = 0; i < howmany; i++) {
(gdb) n
53          write(soc, piece, howmany);
(gdb) n
54          current_byte += howmany;
(gdb) n
44        while (current_byte < total_bytes) {
(gdb) n
45          howmany = rand() % (MAXCHARS - MINCHARS + 1) + MINCHARS;
(gdb) 
46          bytes_left = total_bytes - current_byte;
(gdb) n
47          if (howmany > bytes_left) {
(gdb) n
50          for (int i = 0; i < howmany; i++) {
(gdb) n
51            piece[i] = message[(current_byte + i) % sizeof(message)];
(gdb) n
50          for (int i = 0; i < howmany; i++) {
(gdb) n
51            piece[i] = message[(current_byte + i) % sizeof(message)];
(gdb) n
50          for (int i = 0; i < howmany; i++) {
(gdb) n
51            piece[i] = message[(current_byte + i) % sizeof(message)];
(gdb) n
50          for (int i = 0; i < howmany; i++) {
(gdb) n
51            piece[i] = message[(current_byte + i) % sizeof(message)];
(gdb) p bf uf
$7 = 0x0
(gdb) p n
50          for (int i = 0; i < howmany; i++) {
(gdb) n
53          write(soc, piece, howmany);
(gdb) quit
A debugging session is active.

        Inferior 1 [process 61424] will be killed.

Quit anyway? (y or n) y
]0;vijaya89@wolf:/h/u12/c5/00/vijaya89/csc209/vijaya89/ex10wolf:~/csc209/vijaya89/ex10$ exui  it
exit

Script done on Mon Mar 27 16:31:42 2017
